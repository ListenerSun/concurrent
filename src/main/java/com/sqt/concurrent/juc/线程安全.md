### 线程安全
- 定义: 当多个 线程访问某个类时，不管运行时环境采用<font color='red'>何种调度方式</font>或者
        这些进程如何交替执行，并且在主调代码中<font color='red'>不需要任何额外的同步或协同</font>
         这个类都能表现出正确的行为，那么就称这个类时线程安全的。
- 线程安全性体现在三个方面:
    1. 原子性:提供了互斥访问，即同一时刻只能有一个线程来对它进行操作。
        - 原子性对比:
            - synchronized:不可中断锁,适合竞争不激烈,可读性好
            - Lock:可中断锁,多样化同步,竞争激烈时能维持常态
            - Atomic:竞争激烈时能维持常态,比Lock性能好,只能同步一个值
    2. 可见性:一个线程对主内存的修改可以及时的被其他线程观察到。
        - 导致共享变量在线程之间不可见的原因:
            - 线程交叉执行
            - 重排序结合线程交叉执行
            - 共享变量更新后的值没有在工作内存与主内存之间及时更新
        -  synchronized对于可见性的作用:
            - 线程解锁前，必须把共享变量的最新值刷新到主内存
            - 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
            - 注:<font color='red'>加锁和解锁是同一把锁
        - volatile对于可见性的作用:
            - 对volatile变量写操作时，会在写操作后加入一条store屏障指令,将本地内存中的共享变量刷新到主内存
            - 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量值
            -  volatile修饰变量不能保证线程安全，不具有原子性     
    3. 有序性:一个线程观察其他线程中的指令执行顺序,由于指令重排的存在，该结果一般杂乱无序(happen-before原则)。
- synchronized:
    1. 修饰代码块:即大括号括起来的代码,作用于<font color='red'>调用的对象(即创建出来的对象,调用时起作用)</font>
    2. 修饰方法: 整个方法,作用于<font color='red'>调用的对象(即创建出来的对象,调用时起作用)</font>
    3. 修饰静态方法:整个静态方法,作用于该类的所有对象
    4. 修饰类:括号括起来的部分,作用于该类的所有对象
    5. 父类的方法有synchronized，子类继承后无效
